<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bioritmo – Calcolatore & Grafico</title>
<meta name="description" content="Calcola e visualizza i bioritmi (Fisico, Emotivo, Intellettuale, Intuizione) a partire dalla tua data di nascita. App 100% locale, nessun dato inviato." />
<style>
  :root{
    --bg:#0e0f13; --panel:#171923; --ink:#e7e8ee; --muted:#9aa0ac;
    --grid:#2a2d3a; --accent:#6aa6ff; --ok:#4bd37b; --warn:#ffb04b; --bad:#ff6b6b;
    --intu:#b67dff; --line:#3a3f52; --chip:#222538;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;
    background:linear-gradient(180deg,#0b0c10,#12141b 25%,#0e0f13 100%); color:var(--ink);
  }
  header{padding:24px 16px; text-align:center}
  header h1{margin:0 0 6px; font-size:clamp(22px,3.5vw,28px); letter-spacing:.3px}
  header p{margin:0; color:var(--muted); font-size:14px}
  .wrap{max-width:1100px; margin:0 auto; padding:12px 16px 40px}
  .card{background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .grid{display:grid; gap:14px; grid-template-columns:1fr}
  @media (min-width:900px){ .grid{grid-template-columns: 380px 1fr;} }
  label{display:block; font-size:13px; color:var(--muted); margin-bottom:6px}
  input[type="date"], input[type="number"], input[type="text"]{
    width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--line); background:#10121a; color:var(--ink); outline:none;
  }
  input[type="checkbox"]{transform:translateY(1px)}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .actions{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
  button{padding:10px 14px; border-radius:10px; border:1px solid var(--line); background:var(--chip); color:var(--ink); cursor:pointer}
  button.primary{background:var(--accent); border-color:transparent; color:#0b1220; font-weight:600}
  button:disabled{opacity:.6; cursor:not-allowed}
  canvas{width:100%; height:360px; background:linear-gradient(180deg,#0f111a,#141724); border:1px solid var(--line); border-radius:12px}

  .legend{display:flex; gap:10px; flex-wrap:wrap; margin:10px 0 0}
  .chip{display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px; background:var(--chip); border:1px solid var(--line); color:var(--ink); font-size:13px}
  .dot{width:12px; height:12px; border-radius:50%}
  .dot.ph{background:var(--ok)} .dot.em{background:var(--warn)} .dot.in{background:var(--bad)} .dot.intu{background:var(--intu)}
  .muted{color:var(--muted)}
  .section-title{margin:14px 0 8px; font-size:14px; color:var(--muted); font-weight:600; letter-spacing:.3px}
  .statgrid{display:grid; grid-template-columns: repeat(2,1fr); gap:8px}
  @media (min-width:560px){ .statgrid{grid-template-columns: repeat(4,1fr);} }
  .stat{background:#10121a; border:1px solid var(--line); border-radius:12px; padding:10px}
  .stat b{display:block; font-size:18px; margin-bottom:4px}
  .stat small{color:var(--muted)}
  .notice{margin-top:8px; font-size:12px; color:var(--muted)}
  .divider{height:1px; background:var(--line); margin:12px 0}
  footer{color:var(--muted); text-align:center; font-size:12px; padding:20px 0}

  /* Legenda fissa nel riquadro del grafico */
  .fixed-legend{
    position:absolute; left:10px; bottom:10px; z-index:2;
    background:rgba(20,22,34,.9); border:1px solid var(--line);
    border-radius:10px; padding:8px 10px; min-width:210px;
    font-size:12px; color:var(--ink); box-shadow:0 6px 20px rgba(0,0,0,.35);
  }
  .fixed-legend .title{font-weight:600; margin-bottom:6px}
  .fixed-legend .row{
    display:grid; grid-template-columns:12px 1fr auto; gap:6px 8px; align-items:center;
  }
  .fixed-legend .sw{width:10px; height:10px; border-radius:50%}
  .fixed-legend .val{font-weight:700}

  @media (max-width: 420px){
    .fixed-legend{
      bottom: 18px;
      font-size: 11px;
      min-width: 190px;
    }
  }
</style>
</head>
<body>
  <header>
    <h1>Calcolatore di Bioritmo</h1>
    <p>Inserisci la tua <b>data di nascita</b>, scegli l’intervallo e visualizza i cicli fisico, emotivo, intellettuale (e intuizione).</p>
  </header>

  <div class="wrap">
    <div class="card grid">
      <!-- Controlli -->
      <section>
        <div class="section-title">Dati</div>

        <label for="name">Nome (opzionale)</label>
        <input id="name" type="text" placeholder="Es. Giulia" />

        <label for="dob" style="margin-top:10px">Data di nascita *</label>
        <input id="dob" type="date" required />

        <div class="row" style="margin-top:10px">
          <div style="flex:1">
            <label for="target">Data di riferimento</label>
            <input id="target" type="date" />
          </div>
          <div>
            <label for="span">Giorni intorno alla data</label>
            <input id="span" type="number" min="7" max="120" step="1" value="30" />
          </div>
        </div>

        <div class="row" style="margin-top:8px">
          <label><input id="showIntu" type="checkbox" /> Includi ciclo <b>Intuizione</b> (38 gg)</label>
        </div>

        <div class="actions">
          <button id="draw" class="primary">Disegna grafico</button>
          <button id="todayBtn">Oggi</button>
          <button id="shareBtn">Condividi</button>
          <button id="saveBtn">Esporta PNG</button>
        </div>

        <div class="divider"></div>

        <div class="section-title">Valori alla data selezionata</div>
        <div class="statgrid" id="stats">
          <div class="stat"><b id="statPh">—</b><small>Fisico (23 gg)</small></div>
          <div class="stat"><b id="statEm">—</b><small>Emotivo (28 gg)</small></div>
          <div class="stat"><b id="statIn">—</b><small>Intellettuale (33 gg)</small></div>
          <div class="stat"><b id="statIntu">—</b><small>Intuizione (38 gg)</small></div>
        </div>

        <p class="notice">
          Nota: i bioritmi sono un concetto popolare ma <i>non scientificamente dimostrato</i>. Usali come spunto ludico, non per decisioni importanti.
        </p>
      </section>

      <!-- Grafico -->
      <section>
        <div id="canvasWrap" style="position:relative">
          <canvas id="chart" width="1200" height="420" aria-label="Grafico bioritmo" role="img"></canvas>

          <!-- Legenda fissa -->
          <div class="fixed-legend" id="fixedLegend">
            <div class="title" id="legendDate">—</div>
            <div class="row">
              <span class="sw" style="background:var(--ok)"></span>
              <span>Fisico</span>
              <span class="val" id="vPh">—</span>
            </div>
            <div class="row">
              <span class="sw" style="background:var(--warn)"></span>
              <span>Emotivo</span>
              <span class="val" id="vEm">—</span>
            </div>
            <div class="row">
              <span class="sw" style="background:var(--bad)"></span>
              <span>Intellettuale</span>
              <span class="val" id="vIn">—</span>
            </div>
            <div class="row" id="rowIntu" style="display:none">
              <span class="sw" style="background:var(--intu)"></span>
              <span>Intuizione</span>
              <span class="val" id="vIntu">—</span>
            </div>
          </div>
        </div>

        <div class="legend" aria-hidden="true">
          <span class="chip"><span class="dot ph"></span> Fisico</span>
          <span class="chip"><span class="dot em"></span> Emotivo</span>
          <span class="chip"><span class="dot in"></span> Intellettuale</span>
          <span class="chip"><span class="dot intu"></span> Intuizione</span>
          <span class="chip muted">Linea 0 = equilibrio</span>
        </div>
      </section>
    </div>
    <footer>© 2025 – Bioritmo demo locale (nessun dato inviato in rete)</footer>
  </div>

<script>
"use strict";
(function(){
  // ========= Utility =========
  const $ = (sel)=>document.querySelector(sel);
  const fmt = (d)=>d.toLocaleDateString('it-IT',{year:'numeric',month:'2-digit',day:'2-digit'});
  const parseISO = (s)=>{ const [y,m,d]=s.split('-').map(Number); return new Date(y,m-1,d); }
  const toISO = (d)=>{ const z=(n)=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}` }

  // ========= Stato & costanti =========
  const periods = {
    ph:{days:23, color:'#4bd37b', label:'Fisico'},
    em:{days:28, color:'#ffb04b', label:'Emotivo'},
    intel:{days:33, color:'#ff6b6b', label:'Intellettuale'},
    intu:{days:38, color:'#b67dff', label:'Intuizione'}
  };

  const els = {
    name: $('#name'),
    dob: $('#dob'),
    target: $('#target'),
    span: $('#span'),
    showIntu: $('#showIntu'),
    draw: $('#draw'),
    todayBtn: $('#todayBtn'),
    shareBtn: $('#shareBtn'),
    saveBtn: $('#saveBtn'),
    statPh: $('#statPh'),
    statEm: $('#statEm'),
    statIn: $('#statIn'),
    statIntu: $('#statIntu'),
    canvas: $('#chart'),
    wrap: $('#canvasWrap'),
    legendBox: $('#fixedLegend'),
    legendDate: $('#legendDate'),
    vPh: $('#vPh'), vEm: $('#vEm'), vIn: $('#vIn'), vIntu: $('#vIntu'),
    rowIntu: $('#rowIntu')
  };
  const ctx = els.canvas.getContext('2d');

  // Padding interno del riquadro disegnabile
  const PAD = { top: 28, right: 12, bottom: 42, left: 46 };

  // Default: oggi
  const today = new Date();
  els.target.value = toISO(today);

  // Parametri da URL (per condivisione)
  const params = new URLSearchParams(location.search);
  if(params.has('dob')) els.dob.value = params.get('dob');
  if(params.has('t')) els.target.value = params.get('t');
  if(params.has('span')) els.span.value = params.get('span');
  if(params.has('intu')) els.showIntu.checked = params.get('intu') === '1';
  if(params.has('name')) els.name.value = params.get('name');

  // ========= Calcoli bioritmo =========
  function daysBetween(a,b){
    const ms = 86400000;
    const da = new Date(a.getFullYear(),a.getMonth(),a.getDate());
    const db = new Date(b.getFullYear(),b.getMonth(),b.getDate());
    return Math.round((db - da)/ms);
  }
  function cycleValue(daysSinceBirth, period){
    const TWO_PI = Math.PI * 2;
    return Math.sin(TWO_PI * (daysSinceBirth/period));
  }
  const percent = (v)=>Math.round(v*100);

  function computeSeries(dob, centerDate, spanDays, includeIntu){
    const start = new Date(centerDate); start.setDate(start.getDate() - spanDays);
    const end = new Date(centerDate); end.setDate(end.getDate() + spanDays);
    const daysTotal = daysBetween(start, end);
    const xs = [];
    const series = {ph:[], em:[], intel:[], intu:[]};
    for(let i=0;i<=daysTotal;i++){
      const d = new Date(start); d.setDate(start.getDate()+i);
      const dsb = daysBetween(dob, d);
      xs.push(d);
      series.ph.push(cycleValue(dsb, periods.ph.days));
      series.em.push(cycleValue(dsb, periods.em.days));
      series.intel.push(cycleValue(dsb, periods.intel.days));
      series.intu.push(includeIntu ? cycleValue(dsb, periods.intu.days) : null);
    }
    return {xs, series, start, end};
  }

  // ========= Mapping coordinate =========
  function mapY(v){ // v -1..+1 -> y in pixel
    const h = els.canvas.height;
    const drawable = h - PAD.top - PAD.bottom;
    return PAD.top + (1 - ((v + 1)/2)) * drawable;
  }
  function mapX(i, total){ // indice giorno -> x in pixel
    const w = els.canvas.width;
    const drawable = w - PAD.left - PAD.right;
    return PAD.left + (i/total) * drawable;
  }

  // ========= Rendering Canvas =========
  let lastData = null; // {xs, series, start, end, total}
  let crossIndex = null; // indice attivo per il marcatore verticale

  function clearCanvas(){
    const {width, height} = els.canvas;
    ctx.clearRect(0,0,width,height);
    // griglia leggera nel riquadro disegnabile
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    const stepY = 20, stepX = 40;
    for(let y = PAD.top; y < height - PAD.bottom; y += stepY){
      ctx.fillRect(PAD.left, y, width - PAD.left - PAD.right, 1);
    }
    for(let x = PAD.left; x < width - PAD.right; x += stepX){
      ctx.fillRect(x, PAD.top, 1, height - PAD.top - PAD.bottom);
    }
  }

  function drawAxes(dateStart, dateEnd){
    const {width, height} = els.canvas;

    // asse Y=0
    const mid = mapY(0);
    ctx.strokeStyle = '#2a2d3a';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(PAD.left, mid); ctx.lineTo(width - PAD.right, mid); ctx.stroke();

    // tacche verticali leggere ogni 5 giorni
    const totalDays = Math.max(1, daysBetween(dateStart, dateEnd));
    for(let i=0;i<=totalDays;i++){
      if(i % 5 === 0){
        const x = mapX(i, totalDays);
        ctx.globalAlpha = 0.2;
        ctx.beginPath(); ctx.moveTo(x, PAD.top); ctx.lineTo(x, height - PAD.bottom); ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }

    // etichette date agli estremi (in alto, dentro il padding)
    ctx.fillStyle = '#9aa0ac';
    ctx.font = (window.innerWidth < 480 ? '13px' : '12px') + ' system-ui, -apple-system, Segoe UI, Roboto';
    ctx.textAlign = 'left';
    ctx.fillText(fmt(dateStart), PAD.left + 4, PAD.top - 8 + 22);
    const text = fmt(dateEnd);
    const tw = ctx.measureText(text).width;
    ctx.textAlign = 'right';
    ctx.fillText(text, width - PAD.right - 4, PAD.top - 8 + 22);

    drawYAxisLabels();
    drawXAxisLabels(dateStart, dateEnd, 7);
  }

  // Y labels: +100, +50, 0, -50, -100
  function drawYAxisLabels(){
    const ticks = [1, 0.5, 0, -0.5, -1];
    const {width} = els.canvas;

    ctx.save();
    ctx.font = (window.innerWidth < 480 ? '14px' : '12px') + ' system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillStyle = '#9aa0ac';
    ctx.strokeStyle = '#2a2d3a';
    ctx.lineWidth = 1;

    ticks.forEach(t=>{
      const y = mapY(t);
      // linea guida dentro ai paddings
      ctx.globalAlpha = t===0 ? 1 : 0.25;
      ctx.beginPath(); ctx.moveTo(PAD.left, y); ctx.lineTo(width - PAD.right, y); ctx.stroke();

      // testo a sinistra (dentro il padding)
      ctx.globalAlpha = 1;
      const label = (t*100>0?'+':'') + Math.round(t*100);
      ctx.textAlign = 'left';
      ctx.fillText(label, 8, y - 4);
    });
    ctx.restore();
  }

  // X labels ogni "stepDays" giorni
  function drawXAxisLabels(dateStart, dateEnd, stepDays){
    const totalDays = Math.max(1, daysBetween(dateStart, dateEnd));
    const {height} = els.canvas;
    const step = Math.max(1, stepDays|0);

    ctx.save();
    ctx.fillStyle = '#9aa0ac';
    ctx.strokeStyle = '#2a2d3a';
    ctx.font = (window.innerWidth < 480 ? '12px' : '11px') + ' system-ui, -apple-system, Segoe UI, Roboto';
    ctx.textAlign = 'center';

    for(let i=0;i<=totalDays;i+=step){
      const x = mapX(i, totalDays);
      // piccola tacca
      ctx.globalAlpha = .6;
      ctx.beginPath(); ctx.moveTo(x, height - PAD.bottom + 4); ctx.lineTo(x, height - PAD.bottom + 12); ctx.stroke();
      ctx.globalAlpha = 1;

      const d = new Date(dateStart); d.setDate(dateStart.getDate()+i);
      const lab = d.toLocaleDateString('it-IT',{day:'2-digit',month:'2-digit'});
      ctx.fillText(lab, x, height - 6); // più in su del bordo
    }
    ctx.restore();
  }

  function drawLine(values, color){
    const n = values.length - 1;
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    values.forEach((v,i)=>{
      if(v === null) return;
      const x = mapX(i, n);
      const y = mapY(v);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();
  }

  function drawToday(centerDate, start, end){
    const total = Math.max(1, daysBetween(start,end));
    const i = Math.max(0, Math.min(total, daysBetween(start, centerDate)));
    const x = mapX(i, total);
    ctx.save();
    ctx.strokeStyle = '#6aa6ff';
    ctx.setLineDash([4,4]);
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(x, PAD.top); ctx.lineTo(x, els.canvas.height - PAD.bottom); ctx.stroke();
    ctx.restore();
  }

  function drawCrosshair(i){
    if(!lastData) return;
    const {total} = lastData;
    const x = mapX(i, total);
    ctx.save();
    ctx.strokeStyle = 'rgba(106,166,255,.9)';
    ctx.setLineDash([6,4]);
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x, PAD.top); ctx.lineTo(x, els.canvas.height - PAD.bottom); ctx.stroke();
    ctx.restore();
  }

  function findCriticals(xs, arr){
    const out = [];
    for(let i=1;i<arr.length;i++){
      if(arr[i-1]===null || arr[i]===null) continue;
      if((arr[i-1] <= 0 && arr[i] > 0) || (arr[i-1] >= 0 && arr[i] < 0)) out.push(xs[i]);
    }
    return out;
  }

  function updateStats(dob, target, includeIntu){
    const dsb = daysBetween(dob, target);
    const vPh = cycleValue(dsb, periods.ph.days);
    const vEm = cycleValue(dsb, periods.em.days);
    const vIn = cycleValue(dsb, periods.intel.days);
    const vIntu = includeIntu ? cycleValue(dsb, periods.intu.days) : null;

    els.statPh.textContent = percent(vPh) + '%';
    els.statEm.textContent = percent(vEm) + '%';
    els.statIn.textContent = percent(vIn) + '%';
    els.statIntu.textContent = vIntu===null ? '—' : percent(vIntu) + '%';
  }

  // Aggiorna legenda fissa
  function updateFixedLegend(date, vals, showIntu){
    els.legendDate.textContent = fmt(date);
    els.vPh.textContent = (vals.ph!=null? percent(vals.ph)+'%':'—');
    els.vEm.textContent = (vals.em!=null? percent(vals.em)+'%':'—');
    els.vIn.textContent = (vals.intel!=null? percent(vals.intel)+'%':'—');
    if(showIntu){
      els.rowIntu.style.display='grid';
      els.vIntu.textContent = (vals.intu!=null? percent(vals.intu)+'%':'—');
    } else {
      els.rowIntu.style.display='none';
    }
  }

  function render(){
    if(!els.dob.value){ // niente alert prima dell’input; disegna solo assi
      clearCanvas(); drawAxes(new Date(), new Date());
      return;
    }
    if(!els.target.value){ els.target.value = toISO(new Date()); }
    const dob = parseISO(els.dob.value);
    const target = parseISO(els.target.value);
    const span = Math.max(7, Math.min(120, Number(els.span.value)||30));
    els.span.value = span;

    const data = computeSeries(dob, target, span, els.showIntu.checked);
    lastData = {...data, total: data.xs.length-1};

    updateStats(dob, target, els.showIntu.checked);

    clearCanvas();
    drawAxes(data.start, data.end);
    drawLine(data.series.ph, periods.ph.color);
    drawLine(data.series.em, periods.em.color);
    drawLine(data.series.intel, periods.intel.color);
    if(els.showIntu.checked) drawLine(data.series.intu, periods.intu.color);
    drawToday(target, data.start, data.end);

    // punti critici
    const crits = [
      ...findCriticals(data.xs, data.series.ph).map(d=>({d,color:periods.ph.color})),
      ...findCriticals(data.xs, data.series.em).map(d=>({d,color:periods.em.color})),
      ...findCriticals(data.xs, data.series.intel).map(d=>({d,color:periods.intel.color})),
      ...(els.showIntu.checked ? findCriticals(data.xs, data.series.intu).map(d=>({d,color:periods.intu.color})) : [])
    ];
    const total = data.xs.length - 1;
    crits.forEach(({d,color})=>{
      const i = daysBetween(data.start,d);
      const x = mapX(i, total);
      const y = mapY(0);
      ctx.fillStyle = color; ctx.strokeStyle = '#000'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill();
    });

    // legenda fissa iniziale = data di riferimento
    const idx = Math.max(0, Math.min(lastData.total, daysBetween(lastData.start, target)));
    updateFixedLegend(
      lastData.xs[idx],
      {
        ph: lastData.series.ph[idx],
        em: lastData.series.em[idx],
        intel: lastData.series.intel[idx],
        intu: lastData.series.intu[idx]
      },
      els.showIntu.checked
    );

    // se c'è un crossIndex attivo, ridisegna il marcatore sopra
    if(crossIndex!=null){ drawCrosshair(crossIndex); }
  }

  // ========= Interazione: crosshair + legenda fissa aggiornata (auto-lato) =========
  function nearestIndexFromClientX(clientX){
    if(!lastData) return null;
    const rect = els.canvas.getBoundingClientRect();
    const x = clientX - rect.left;
    const i = Math.round((x/els.canvas.width) * lastData.total);
    return Math.max(0, Math.min(lastData.total, i));
  }

  function updateInteractionAt(i){
    if(!lastData) return;
    crossIndex = i;
    render(); // ridisegna tutto (marcatore incluso)

    // aggiorna legenda sui valori correnti
    updateFixedLegend(
      lastData.xs[i],
      {
        ph: lastData.series.ph[i],
        em: lastData.series.em[i],
        intel: lastData.series.intel[i],
        intu: lastData.series.intu[i]
      },
      els.showIntu.checked
    );

    // sposta la legenda a sinistra/destra per non coprire il punto attivo
    const half = els.canvas.width / 2;
    const x = mapX(i, lastData.total);
    const isRight = x > half;
    els.legendBox.style.left  = isRight ? '' : '10px';
    els.legendBox.style.right = isRight ? '10px' : '';
  }

  function clearInteraction(){
    crossIndex = null;
    // reset posizione legenda lato sinistro
    els.legendBox.style.right = '';
    els.legendBox.style.left  = '10px';
    render();
  }

  // Mouse
  els.canvas.addEventListener('mousemove', (e)=>{
    const i = nearestIndexFromClientX(e.clientX);
    if(i==null) return;
    updateInteractionAt(i);
  });
  els.canvas.addEventListener('mouseleave', clearInteraction);

  // Touch
  els.canvas.addEventListener('touchstart', (e)=>{
    const t = e.changedTouches[0];
    const i = nearestIndexFromClientX(t.clientX);
    if(i==null) return;
    updateInteractionAt(i);
  }, {passive:true});
  els.canvas.addEventListener('touchmove', (e)=>{
    const t = e.changedTouches[0];
    const i = nearestIndexFromClientX(t.clientX);
    if(i==null) return;
    updateInteractionAt(i);
  }, {passive:true});
  els.canvas.addEventListener('touchend', clearInteraction);
  els.canvas.addEventListener('touchcancel', clearInteraction);

  // ========= Eventi base =========
  els.draw.addEventListener('click', ()=>{ render(); });
  els.todayBtn.addEventListener('click', ()=>{ els.target.value = toISO(new Date()); render(); });
  [els.dob, els.target, els.span, els.showIntu].forEach(el=> el.addEventListener('change', ()=>{ render(); }));

  // Condivisione via URL
  els.shareBtn.addEventListener('click', ()=>{
    if(!els.dob.value){ alert('Inserisci la data di nascita.'); return; }
    const p = new URLSearchParams();
    p.set('dob', els.dob.value);
    if(els.target.value) p.set('t', els.target.value);
    p.set('span', els.span.value);
    if(els.showIntu.checked) p.set('intu', '1');
    if(els.name.value) p.set('name', els.name.value);
    const url = location.origin + location.pathname + '?' + p.toString();
    navigator.clipboard?.writeText(url);
    alert('Link copiato negli appunti:\n' + url);
  });

  // Salva PNG
  els.saveBtn.addEventListener('click', ()=>{
    const a = document.createElement('a');
    const name = els.name.value ? `_${els.name.value}` : '';
    a.download = `bioritmo${name || ''}_${els.target.value || toISO(new Date())}.png`;
    a.href = els.canvas.toDataURL('image/png');
    a.click();
  });

  // Retina fit & redraw
  const ctx2d = els.canvas.getContext('2d');
  function fitCanvas(){
    const ratio = window.devicePixelRatio || 1;
    const w = Math.max(300, els.canvas.clientWidth);
    const h = Math.max(260, els.canvas.clientHeight);
    const W = Math.round(w*ratio), H = Math.round(h*ratio);
    if(els.canvas.width !== W || els.canvas.height !== H){
      els.canvas.width = W; els.canvas.height = H;
      ctx2d.setTransform(ratio,0,0,ratio,0,0);
      render();
    }
  }
  window.addEventListener('resize', ()=>{ fitCanvas(); });

  // Primo render (ed eventuali parametri via URL)
  fitCanvas();
  if(els.dob.value){ render(); } else { clearCanvas(); drawAxes(new Date(), new Date()); }
})();
</script>
</body>
</html>